import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ApiError, requestJson } from "./lib/api-client";
import type { Book, Loan, Role, User } from "./types";

type AuthResponse = {
  accessToken: string;
  user: User;
};

type BooksResponse = {
  data: Book[];
  pageInfo: {
    hasNextPage: boolean;
    nextCursor: string | null;
  };
};

type LibraryStatsResponse = {
  data: {
    totalBooks: number;
    availableBooks: number;
    checkedOutBooks: number;
    activeLoans: number;
  };
};

type SearchFallbackResponse = {
  data: Book[];
  meta?: {
    source?: string | null;
    fallbackUsed?: boolean;
    importedCount?: number;
    existingCount?: number;
  };
};

type EnrichMetadataResponse = {
  meta: {
    providerUsed: string;
    processed: number;
    updatedCount: number;
    skippedCount: number;
    noMatchCount: number;
    failedCount: number;
  };
};

type EnrichCoreMetadataResponse = {
  meta: {
    providerUsed: string;
    processed: number;
    updatedCount: number;
    autoGeneratedCount: number;
    noMatchCount: number;
    failedCount: number;
  };
};

type BorrowerOverview = {
  user: Pick<User, "id" | "name" | "email" | "contactEmail" | "phoneNumber" | "personalId" | "readingPoints">;
  activeLoans: Loan[];
  overdueCount: number;
};

type AdminLoansOverviewResponse = {
  data: {
    borrowers: BorrowerOverview[];
    overdueLoans: Loan[];
    overdueUsers: number;
  };
};

type UpdateContactResponse = {
  data: User;
};

type BorrowRequestStatus = "PENDING" | "APPROVED" | "DECLINED";

type BorrowRequestItem = {
  id: string;
  status: BorrowRequestStatus;
  createdAt: string;
  updatedAt: string;
  reviewedAt: string | null;
  memberSeenAt: string | null;
  user: Pick<User, "id" | "name" | "email" | "role" | "contactEmail" | "phoneNumber" | "personalId" | "readingPoints">;
  book: Book;
  reviewedBy: {
    id: string;
    name: string;
    email: string;
  } | null;
};

type BorrowRequestsResponse = {
  data: BorrowRequestItem[];
  meta: {
    pendingCount: number;
    unreadForMember: number;
  };
};

type UiLogEntry = {
  id: string;
  text: string;
  createdAt: string;
};

type BookReviewEntry = {
  id: string;
  rating: number;
  content: string;
  createdAt: string;
  updatedAt: string;
  user: {
    id: string;
    name: string;
    readingPoints: number;
  };
};

type BookDetailsResponse = {
  data: {
    book: Book;
    relatedBooks: Book[];
    reviews: BookReviewEntry[];
    myReview: {
      id: string;
      rating: number;
      content: string;
      updatedAt: string;
    } | null;
    myNote: {
      id: string;
      content: string;
      updatedAt: string;
    } | null;
    reviewSummary: {
      count: number;
      averageRating: number | null;
    };
  };
};

type ImportProvider = "auto" | "openlibrary" | "google";
type ViewMode = "catalog" | "dashboard" | "settings";
type AvatarPreset = {
  id: string;
  label: string;
  emoji: string;
  innerBackground: string;
};
type BackgroundPreset = {
  id: string;
  label: string;
  background: string;
};

const avatarPresets: AvatarPreset[] = [
  { id: "avatar-1", label: "Forest Owl", emoji: "ðŸ¦‰", innerBackground: "linear-gradient(140deg,#365d3f,#23412a)" },
  { id: "avatar-2", label: "Blue Wave", emoji: "ðŸŒŠ", innerBackground: "linear-gradient(140deg,#3b6ea8,#274978)" },
  { id: "avatar-3", label: "Sunrise", emoji: "ðŸŒ…", innerBackground: "linear-gradient(140deg,#d2862f,#8d4f18)" },
  { id: "avatar-4", label: "Rocket", emoji: "ðŸš€", innerBackground: "linear-gradient(140deg,#5a4ea2,#382f74)" },
  { id: "avatar-5", label: "Leaf", emoji: "ðŸƒ", innerBackground: "linear-gradient(140deg,#4e8645,#2f5c2a)" },
  { id: "avatar-6", label: "Comet", emoji: "â˜„ï¸", innerBackground: "linear-gradient(140deg,#7a3d52,#4e2635)" },
  { id: "avatar-7", label: "Book", emoji: "ðŸ“˜", innerBackground: "linear-gradient(140deg,#466f87,#264350)" },
  { id: "avatar-8", label: "Crown", emoji: "ðŸ‘‘", innerBackground: "linear-gradient(140deg,#8b6d2d,#5d491c)" },
  { id: "avatar-9", label: "Fox", emoji: "ðŸ¦Š", innerBackground: "linear-gradient(140deg,#9a4c30,#6a311c)" },
  { id: "avatar-10", label: "Moon", emoji: "ðŸŒ™", innerBackground: "linear-gradient(140deg,#4e5668,#333a49)" }
];
const backgroundPresets: BackgroundPreset[] = [
  {
    id: "bg-1",
    label: "Sand Glow",
    background:
      "radial-gradient(circle at 20% 10%, #e9e4d8 0%, transparent 45%),radial-gradient(circle at 80% 0%, #f6ead2 0%, transparent 35%),#f6f3ea"
  },
  {
    id: "bg-2",
    label: "Northern Blue",
    background:
      "radial-gradient(circle at 15% 18%, #d9e9f8 0%, transparent 46%),radial-gradient(circle at 85% 4%, #cde7f7 0%, transparent 33%),#eef6fb"
  },
  {
    id: "bg-3",
    label: "Moss",
    background:
      "radial-gradient(circle at 18% 14%, #dcead7 0%, transparent 45%),radial-gradient(circle at 82% 4%, #e5f0dd 0%, transparent 33%),#f2f7ef"
  },
  {
    id: "bg-4",
    label: "Rose",
    background:
      "radial-gradient(circle at 18% 16%, #f3dfe0 0%, transparent 44%),radial-gradient(circle at 86% 5%, #f8e6dd 0%, transparent 31%),#f9f0ee"
  },
  {
    id: "bg-5",
    label: "Violet Mist",
    background:
      "radial-gradient(circle at 20% 14%, #e3ddf3 0%, transparent 45%),radial-gradient(circle at 83% 4%, #ece5fa 0%, transparent 32%),#f4f1fb"
  },
  {
    id: "bg-6",
    label: "Steel",
    background:
      "radial-gradient(circle at 18% 14%, #d9dfe6 0%, transparent 45%),radial-gradient(circle at 84% 4%, #e3e9ef 0%, transparent 32%),#f2f5f8"
  },
  {
    id: "bg-7",
    label: "Sunset",
    background:
      "radial-gradient(circle at 17% 13%, #f7dccb 0%, transparent 45%),radial-gradient(circle at 84% 5%, #f8e6cc 0%, transparent 33%),#fbf2e7"
  },
  {
    id: "bg-8",
    label: "Aqua",
    background:
      "radial-gradient(circle at 20% 12%, #d9f0ed 0%, transparent 45%),radial-gradient(circle at 83% 5%, #dff7f2 0%, transparent 32%),#edf9f5"
  },
  {
    id: "bg-9",
    label: "Night Sky",
    background:
      "radial-gradient(circle at 20% 12%, #1f2b44 0%, transparent 42%),radial-gradient(circle at 84% 6%, #2b3451 0%, transparent 32%),#111827"
  },
  {
    id: "bg-10",
    label: "Coffee",
    background:
      "radial-gradient(circle at 20% 12%, #e7ddd4 0%, transparent 45%),radial-gradient(circle at 82% 6%, #efe4d8 0%, transparent 32%),#f5eee8"
  }
];
const defaultAvatarPresetId = avatarPresets[0].id;
const defaultBackgroundPresetId = backgroundPresets[0].id;

const getAvatarPreset = (id: string | null | undefined): AvatarPreset => {
  return avatarPresets.find((preset) => preset.id === id) ?? avatarPresets[0];
};

const getBackgroundPreset = (id: string | null | undefined): BackgroundPreset => {
  return backgroundPresets.find((preset) => preset.id === id) ?? backgroundPresets[0];
};

const getLevelRingColor = (levelNumber: number): string => {
  if (levelNumber >= 4) {
    return "#f2b94f";
  }
  if (levelNumber === 3) {
    return "#8d6df0";
  }
  if (levelNumber === 2) {
    return "#29b38d";
  }
  return "#4f8cd4";
};

const emptyBookForm = {
  title: "",
  author: "",
  isbn: "",
  genre: "",
  publishedYear: "",
  description: "",
  coverUrl: ""
};

const parseApiError = (error: unknown): string => {
  if (error instanceof ApiError) {
    return error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return "Something unexpected happened.";
};

const toNullableText = (value: string): string | null => {
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
};

const toDateInputValue = (isoDate: string | null): string => {
  if (!isoDate) {
    return "";
  }
  return new Date(isoDate).toISOString().slice(0, 10);
};

const getLevelInfo = (points: number) => {
  const safePoints = Math.max(0, Math.floor(points));
  const baseCap = 100;
  const growth = 1.5;
  const levelNames = ["Noob", "Reader", "Pro", "King"];

  let levelNumber = 1;
  let levelFloor = 0;
  let levelCap = baseCap;
  while (safePoints >= levelCap) {
    levelNumber += 1;
    levelFloor = levelCap;
    levelCap += Math.round(baseCap * Math.pow(growth, levelNumber - 2));
  }

  const pointsIntoLevel = safePoints - levelFloor;
  const pointsNeededInLevel = Math.max(1, levelCap - levelFloor);
  const progressPercent = Math.max(0, Math.min(100, Math.round((pointsIntoLevel / pointsNeededInLevel) * 100)));
  const levelName = levelNumber <= levelNames.length ? levelNames[levelNumber - 1] : `Legend ${levelNumber}`;

  return {
    levelNumber,
    levelName,
    totalPoints: safePoints,
    pointsIntoLevel,
    pointsNeededInLevel,
    progressPercent
  };
};

type FavoriteToggleResponse = {
  data: {
    bookId: string;
    isFavorite: boolean;
  };
};

const truncateText = (value: string, maxLength = 100): string => {
  if (value.length <= maxLength) {
    return value;
  }
  return `${value.slice(0, maxLength - 1).trimEnd()}...`;
};

const getBookIdFromPath = (): string | null => {
  const match = window.location.pathname.match(/^\/books\/([^/]+)$/);
  return match ? decodeURIComponent(match[1]) : null;
};

const isInteractiveTarget = (target: EventTarget | null): boolean => {
  return target instanceof HTMLElement && Boolean(target.closest("button, a, input, select, textarea, label"));
};

const normalizeCoverUrl = (value: string): string => {
  return value.startsWith("http://") ? `https://${value.slice("http://".length)}` : value;
};

const getBookCoverCandidates = (book: Book): string[] => {
  const candidates: string[] = [];
  if (book.coverUrl) {
    candidates.push(normalizeCoverUrl(book.coverUrl));
  }
  if (book.isbn) {
    candidates.push(`https://covers.openlibrary.org/b/isbn/${book.isbn}-L.jpg`);
  }
  const googleQuery = encodeURIComponent(`intitle:${book.title} inauthor:${book.author}`);
  candidates.push(`https://books.google.com/books/content?printsec=frontcover&img=1&zoom=1&source=gbs_api&q=${googleQuery}`);
  return [...new Set(candidates)];
};

const formatRatingCount = (count: number | null): string => {
  if (!count) {
    return "0";
  }
  return Intl.NumberFormat().format(count);
};

const BookRating = ({ book }: { book: Book }) => {
  if (book.averageRating === null) {
    return <p className="rating-line muted">No ratings yet</p>;
  }

  const rounded = Math.round(book.averageRating);
  const stars = `${"*".repeat(rounded)}${".".repeat(Math.max(0, 5 - rounded))}`;

  return (
    <p className="rating-line" aria-label={`${book.averageRating.toFixed(1)} out of 5`}>
      <span className="rating-stars" aria-hidden="true">
        {stars}
      </span>
      <span className="rating-value">{book.averageRating.toFixed(1)}</span>
      <span className="rating-count">({formatRatingCount(book.ratingsCount)})</span>
    </p>
  );
};

const AiMetadataBadge = ({ book }: { book: Book }) => {
  if (!book.aiMetadata) {
    return null;
  }
  return (
    <span className="ai-badge" title="Metadata enhanced by AI" aria-label="AI metadata">
      AI
    </span>
  );
};

const FavoriteStarButton = ({
  bookId,
  isFavorite,
  isPending,
  onToggle
}: {
  bookId: string;
  isFavorite: boolean;
  isPending: boolean;
  onToggle: (bookId: string) => Promise<void>;
}) => {
  return (
    <button
      className={`favorite-star-btn ${isFavorite ? "active" : ""}`}
      type="button"
      onClick={(event) => {
        event.stopPropagation();
        void onToggle(bookId);
      }}
      disabled={isPending}
      aria-label={isFavorite ? "Remove from favorites" : "Add to favorites"}
      title={isFavorite ? "Remove from favorites" : "Add to favorites"}
    >
      {isPending ? "..." : isFavorite ? "â˜…" : "â˜†"}
    </button>
  );
};

const DashboardIcon = () => (
  <svg viewBox="0 0 24 24" aria-hidden="true" className="profile-icon-svg">
    <rect x="3" y="11" width="4" height="10" rx="1.2" />
    <rect x="10" y="7" width="4" height="14" rx="1.2" />
    <rect x="17" y="3" width="4" height="18" rx="1.2" />
  </svg>
);

const SettingsIcon = () => (
  <svg viewBox="0 0 24 24" aria-hidden="true" className="profile-icon-svg">
    <path d="M19.14 12.94a7.5 7.5 0 0 0 .05-.94 7.5 7.5 0 0 0-.05-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.24 7.24 0 0 0-1.63-.94l-.36-2.54a.5.5 0 0 0-.5-.42h-3.84a.5.5 0 0 0-.5.42L8.2 5.32a7.24 7.24 0 0 0-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L1.66 8.84a.5.5 0 0 0 .12.64l2.03 1.58a7.5 7.5 0 0 0-.05.94c0 .32.02.63.05.94L1.78 14.52a.5.5 0 0 0-.12.64l1.92 3.32a.5.5 0 0 0 .6.22l2.39-.96c.5.4 1.05.72 1.63.94l.36 2.54a.5.5 0 0 0 .5.42h3.84a.5.5 0 0 0 .5-.42l.36-2.54c.58-.22 1.13-.54 1.63-.94l2.39.96a.5.5 0 0 0 .6-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58ZM12 15.4a3.4 3.4 0 1 1 0-6.8 3.4 3.4 0 0 1 0 6.8Z" />
  </svg>
);

const LogoutIcon = () => (
  <svg viewBox="0 0 24 24" aria-hidden="true" className="profile-icon-svg">
    <path d="M15.75 4.5v3a.75.75 0 0 1-1.5 0v-3A1.5 1.5 0 0 0 12.75 3h-7.5a1.5 1.5 0 0 0-1.5 1.5v15A1.5 1.5 0 0 0 5.25 21h7.5a1.5 1.5 0 0 0 1.5-1.5v-3a.75.75 0 0 1 1.5 0v3a3 3 0 0 1-3 3h-7.5a3 3 0 0 1-3-3v-15a3 3 0 0 1 3-3h7.5a3 3 0 0 1 3 3Z" />
    <path d="M21.53 12.53a.75.75 0 0 0 0-1.06l-3-3a.75.75 0 0 0-1.06 1.06l1.72 1.72H9a.75.75 0 0 0 0 1.5h10.19l-1.72 1.72a.75.75 0 0 0 1.06 1.06l3-3Z" />
  </svg>
);

const BookCover = ({ book, className }: { book: Book; className: string }) => {
  const [candidateIndex, setCandidateIndex] = useState(0);
  const coverCandidates = useMemo(() => getBookCoverCandidates(book), [book]);

  useEffect(() => {
    setCandidateIndex(0);
  }, [book]);

  const fallbackLabel = book.title
    .split(" ")
    .filter((part) => part.length > 0)
    .slice(0, 2)
    .map((part) => part[0]?.toUpperCase())
    .join("");

  if (coverCandidates.length === 0 || candidateIndex >= coverCandidates.length) {
    return <div className={`${className} cover-fallback`}>{fallbackLabel || "BK"}</div>;
  }

  return (
    <img
      className={className}
      src={coverCandidates[candidateIndex]}
      alt={`Cover of ${book.title}`}
      loading="lazy"
      onError={() => setCandidateIndex((current) => current + 1)}
    />
  );
};

const BookPreviewDialog = ({
  book,
  onClose,
  onCheckout
}: {
  book: Book | null;
  onClose: () => void;
  onCheckout: (bookId: string) => Promise<void>;
}) => {
  useEffect(() => {
    if (!book) {
      return;
    }
    const onKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        onClose();
      }
    };
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [book, onClose]);

  if (!book) {
    return null;
  }

  const externalInfoUrl = `https://openlibrary.org/search?q=${encodeURIComponent(`${book.title} ${book.author}`)}`;

  return (
    <div className="modal-backdrop" role="presentation" onClick={onClose}>
      <section
        className="modal-card"
        role="dialog"
        aria-modal="true"
        aria-labelledby="book-preview-title"
        onClick={(event) => event.stopPropagation()}
      >
        <div className="modal-head">
          <h2 id="book-preview-title">Book preview</h2>
          <button className="btn btn-outline" type="button" onClick={onClose}>
            Close
          </button>
        </div>
        <div className="modal-content">
          <BookCover book={book} className="book-cover-large" />
          <div className="modal-info">
            <div className="title-row">
              <h3>{book.title}</h3>
              <AiMetadataBadge book={book} />
            </div>
            <p className="muted">{book.author}</p>
            <BookRating book={book} />
            <p>
              <strong>Genre:</strong> {book.genre ?? "Uncategorized"}
            </p>
            <p>
              <strong>Published:</strong> {book.publishedYear ?? "Unknown"}
            </p>
            <p>
              <strong>ISBN:</strong> {book.isbn ?? "N/A"}
            </p>
            <p className="book-description">
              {book.description ??
                "No summary available for this book yet. Try importing from Google Books for richer metadata."}
            </p>
            <a className="text-link" href={externalInfoUrl} target="_blank" rel="noreferrer">
              More details
            </a>
            <div className="row-actions">
              {book.available ? (
                <button
                  className="btn"
                  type="button"
                  onClick={() => {
                    void onCheckout(book.id);
                    onClose();
                  }}
                >
                  Borrow this book
                </button>
              ) : (
                <span className="muted">This book is currently checked out (borrowed).</span>
              )}
            </div>
          </div>
        </div>
      </section>
    </div>
  );
};

const GoogleSignInButton = ({
  onGoogleCredential,
  targetId,
  width = 220
}: {
  onGoogleCredential: (credential: string) => Promise<void>;
  targetId: string;
  width?: number;
}) => {
  const googleClientId = import.meta.env.VITE_GOOGLE_CLIENT_ID as string | undefined;

  useEffect(() => {
    if (!googleClientId) {
      return;
    }

    const renderButton = () => {
      const target = document.getElementById(targetId);
      if (!target || !window.google?.accounts?.id) {
        return;
      }

      window.google.accounts.id.initialize({
        client_id: googleClientId,
        callback: ({ credential }) => {
          void onGoogleCredential(credential);
        }
      });
      window.google.accounts.id.renderButton(target, {
        type: "standard",
        theme: "outline",
        text: "signin_with",
        size: "medium",
        shape: "pill",
        width
      });
    };

    if (window.google?.accounts?.id) {
      renderButton();
      return;
    }

    const existingScript = document.querySelector<HTMLScriptElement>("script[data-google-signin='true']");
    if (existingScript) {
      existingScript.addEventListener("load", renderButton);
      return () => {
        existingScript.removeEventListener("load", renderButton);
      };
    }

    const script = document.createElement("script");
    script.src = "https://accounts.google.com/gsi/client";
    script.async = true;
    script.defer = true;
    script.dataset.googleSignin = "true";
    script.onload = renderButton;
    document.body.appendChild(script);
  }, [googleClientId, onGoogleCredential, targetId, width]);

  return (
    <div>
      <div id={targetId} aria-label="Google Sign In button" />
      {!googleClientId && (
        <p className="notice" role="alert">
          Missing <code>VITE_GOOGLE_CLIENT_ID</code>.
        </p>
      )}
    </div>
  );
};

const ProfileMenu = ({
  user,
  busy,
  borrowedCount,
  adminPendingCount,
  memberUnreadRequestCount,
  onGoogleCredential,
  onLogout,
  onOpenDashboard,
  onOpenSettings
}: {
  user: User | null;
  busy: boolean;
  borrowedCount: number;
  adminPendingCount: number;
  memberUnreadRequestCount: number;
  onGoogleCredential: (credential: string) => Promise<void>;
  onLogout: () => void;
  onOpenDashboard: () => void;
  onOpenSettings: () => void;
}) => {
  const [open, setOpen] = useState(false);
  const rootRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const onDocumentClick = (event: MouseEvent) => {
      const element = rootRef.current;
      if (!element || element.contains(event.target as Node)) {
        return;
      }
      setOpen(false);
    };

    const onEscape = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", onDocumentClick);
    document.addEventListener("keydown", onEscape);
    return () => {
      document.removeEventListener("mousedown", onDocumentClick);
      document.removeEventListener("keydown", onEscape);
    };
  }, []);

  const initials = user?.name
    .split(" ")
    .filter((part) => part.length > 0)
    .slice(0, 2)
    .map((part) => part[0]?.toUpperCase())
    .join("") ?? "U";
  const userLevel = user ? getLevelInfo(user.readingPoints) : null;
  const avatarPreset = getAvatarPreset(user?.avatarPreset);
  const ringColor = userLevel ? getLevelRingColor(userLevel.levelNumber) : "#4f8cd4";
  const notificationCount = user?.role === "ADMIN" ? adminPendingCount : memberUnreadRequestCount;

  return (
    <div className="topbar-actions" ref={rootRef}>
      <button
        className="profile-trigger"
        type="button"
        aria-haspopup="menu"
        aria-expanded={open}
        aria-label={user ? `Open profile menu for ${user.name}` : "Open profile menu"}
        onClick={() => setOpen((value) => !value)}
        style={
          userLevel
            ? {
                background: `conic-gradient(${ringColor} ${userLevel.progressPercent}%, #d9e1eb ${userLevel.progressPercent}% 100%)`,
                boxShadow: `0 0 0 1px rgba(25, 35, 52, 0.2), 0 0 12px ${ringColor}66`
              }
            : undefined
        }
      >
        <span className="profile-avatar" style={{ background: avatarPreset.innerBackground }}>
          {user ? avatarPreset.emoji : initials}
        </span>
        {notificationCount > 0 && <span className="profile-notification-badge">{notificationCount}</span>}
      </button>
      {userLevel && (
        <div className="profile-level-mini" aria-label={`Level ${userLevel.levelNumber}, ${userLevel.progressPercent}% progress`}>
          <p className="profile-level-label">{userLevel.levelName}</p>
          <p className="profile-xp-chip">{`${userLevel.totalPoints} XP`}</p>
        </div>
      )}

      {open && (
        <section className={`profile-dropdown${user ? " profile-dropdown-compact" : ""}`} role="menu" aria-label="Profile menu">
          {!user ? (
            <>
              <p className="profile-title">Guest mode</p>
              <p className="muted">Browse books now. Sign in to borrow.</p>
              <GoogleSignInButton onGoogleCredential={onGoogleCredential} targetId="google-signin-profile" width={205} />
              {busy && <p className="profile-status muted">Signing in...</p>}
            </>
          ) : (
            <>
              <p className="profile-title">{user.name}</p>
              <p className="muted">{user.role}</p>
              <p className="muted">{`Level ${userLevel?.levelNumber ?? 1}`}</p>
              <div className="profile-actions-row">
                <button
                  className="btn btn-outline profile-btn-small profile-icon-btn profile-icon-dashboard"
                  type="button"
                  aria-label="Open dashboard"
                  title={`Dashboard (${borrowedCount} borrowed)`}
                  onClick={() => {
                    onOpenDashboard();
                    setOpen(false);
                  }}
                >
                  <DashboardIcon />
                </button>
                <button
                  className="btn btn-outline profile-btn-small profile-icon-btn profile-icon-settings"
                  type="button"
                  aria-label="Open settings"
                  title="Settings"
                  onClick={() => {
                    onOpenSettings();
                    setOpen(false);
                  }}
                >
                  <SettingsIcon />
                </button>
                <button
                  className="btn btn-outline profile-btn-small profile-icon-btn profile-icon-logout"
                  aria-label={user.role === "ADMIN" ? `Sign out (pending: ${adminPendingCount})` : `Sign out (updates: ${memberUnreadRequestCount})`}
                  title="Sign out"
                  onClick={() => {
                    onLogout();
                    setOpen(false);
                  }}
                  type="button"
                >
                  <LogoutIcon />
                </button>
              </div>
            </>
          )}
        </section>
      )}
    </div>
  );
};

const App = () => {
  const [booting, setBooting] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(() => localStorage.getItem("mlms_access_token"));
  const [message, setMessage] = useState("Welcome.");
  const [signingIn, setSigningIn] = useState(false);
  const [viewMode, setViewMode] = useState<ViewMode>("catalog");
  const [showDueSoonDetails, setShowDueSoonDetails] = useState(false);
  const [shouldLoadRecommendations, setShouldLoadRecommendations] = useState(false);

  const [books, setBooks] = useState<Book[]>([]);
  const [hasNextPage, setHasNextPage] = useState(false);
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [booksLoading, setBooksLoading] = useState(false);
  const [libraryStats, setLibraryStats] = useState<LibraryStatsResponse["data"] | null>(null);

  const [loans, setLoans] = useState<Loan[]>([]);
  const [loansLoading, setLoansLoading] = useState(false);
  const [borrowRequests, setBorrowRequests] = useState<BorrowRequestItem[]>([]);
  const [borrowRequestsLoading, setBorrowRequestsLoading] = useState(false);
  const [borrowRequestActionId, setBorrowRequestActionId] = useState<string | null>(null);
  const [memberUnreadRequestCount, setMemberUnreadRequestCount] = useState(0);
  const [adminPendingRequestCount, setAdminPendingRequestCount] = useState(0);
  const [borrowersOverview, setBorrowersOverview] = useState<BorrowerOverview[]>([]);
  const [overdueLoans, setOverdueLoans] = useState<Loan[]>([]);
  const [overdueUsersCount, setOverdueUsersCount] = useState(0);
  const [adminOverviewLoading, setAdminOverviewLoading] = useState(false);
  const [dueDateDrafts, setDueDateDrafts] = useState<Record<string, string>>({});
  const [dueDateUpdatingId, setDueDateUpdatingId] = useState<string | null>(null);
  const [checkoutPendingIds, setCheckoutPendingIds] = useState<string[]>([]);
  const [favoritePendingIds, setFavoritePendingIds] = useState<string[]>([]);
  const [favoriteBooks, setFavoriteBooks] = useState<Book[]>([]);
  const [favoriteBooksLoading, setFavoriteBooksLoading] = useState(false);
  const [recommendations, setRecommendations] = useState<Book[]>([]);
  const [recommendationsLoading, setRecommendationsLoading] = useState(false);
  const [users, setUsers] = useState<User[]>([]);
  const [adminLoading, setAdminLoading] = useState(false);
  const [savingContact, setSavingContact] = useState(false);
  const [savingAppearance, setSavingAppearance] = useState(false);
  const [contactDraft, setContactDraft] = useState({
    contactEmail: "",
    phoneNumber: "",
    personalId: ""
  });
  const [appearanceDraft, setAppearanceDraft] = useState({
    avatarPreset: defaultAvatarPresetId,
    backgroundPreset: defaultBackgroundPresetId
  });

  const [query, setQuery] = useState("");
  const [availableFilter, setAvailableFilter] = useState("all");
  const [importQuery, setImportQuery] = useState("popular fiction");
  const [importLimit, setImportLimit] = useState("50");
  const [importProvider, setImportProvider] = useState<ImportProvider>("auto");
  const [importingExternal, setImportingExternal] = useState(false);
  const [enrichLimit, setEnrichLimit] = useState("200");
  const [enrichingMetadata, setEnrichingMetadata] = useState(false);
  const [enrichingCoreMetadata, setEnrichingCoreMetadata] = useState(false);
  const [previewBook, setPreviewBook] = useState<Book | null>(null);
  const [showBookEditor, setShowBookEditor] = useState(false);
  const [editingBookId, setEditingBookId] = useState<string | null>(null);
  const [bookForm, setBookForm] = useState(emptyBookForm);
  const [submittingBook, setSubmittingBook] = useState(false);
  const [activeBookId, setActiveBookId] = useState<string | null>(() => getBookIdFromPath());
  const [bookDetails, setBookDetails] = useState<BookDetailsResponse["data"] | null>(null);
  const [bookDetailsLoading, setBookDetailsLoading] = useState(false);
  const [reviewDraft, setReviewDraft] = useState({
    rating: "5",
    content: ""
  });
  const [noteDraft, setNoteDraft] = useState("");
  const [savingReview, setSavingReview] = useState(false);
  const [savingNote, setSavingNote] = useState(false);
  const [shareFeedback, setShareFeedback] = useState("");
  const [adminLogs, setAdminLogs] = useState<UiLogEntry[]>([]);

  const tokenRef = useRef<string | null>(accessToken);

  useEffect(() => {
    tokenRef.current = accessToken;
    if (accessToken) {
      localStorage.setItem("mlms_access_token", accessToken);
    } else {
      localStorage.removeItem("mlms_access_token");
    }
  }, [accessToken]);

  useEffect(() => {
    const text = message.trim();
    if (!text) {
      return;
    }
    setAdminLogs((current) => {
      if (current[0]?.text === text) {
        return current;
      }
      const entry: UiLogEntry = {
        id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        text,
        createdAt: new Date().toISOString()
      };
      return [entry, ...current].slice(0, 120);
    });
  }, [message]);

  const refreshAccessToken = useCallback(async (): Promise<string> => {
    const result = await requestJson<{ accessToken: string }>("/auth/refresh", {
      method: "POST"
    });
    setAccessToken(result.accessToken);
    return result.accessToken;
  }, []);

  const authRequest = useCallback(
    async <TResponse,>(path: string, options: { method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE"; body?: unknown } = {}) => {
      try {
        return await requestJson<TResponse>(path, {
          ...options,
          accessToken: tokenRef.current
        });
      } catch (error) {
        if (error instanceof ApiError && error.statusCode === 401) {
          const refreshedToken = await refreshAccessToken();
          return requestJson<TResponse>(path, {
            ...options,
            accessToken: refreshedToken
          });
        }
        throw error;
      }
    },
    [refreshAccessToken]
  );

  const loadBooks = useCallback(
    async (cursor?: string | null) => {
      setBooksLoading(true);
      try {
        const params = new URLSearchParams();
        if (query.trim()) {
          params.set("q", query.trim());
        }
        if (availableFilter !== "all") {
          params.set("available", availableFilter === "available" ? "true" : "false");
        }
        params.set("limit", "12");
        if (cursor) {
          params.set("cursor", cursor);
        }

        const result = await requestJson<BooksResponse>(`/books?${params.toString()}`, {
          accessToken: tokenRef.current
        });
        const isInitialSearch = !cursor;
        if (isInitialSearch && query.trim() && result.data.length === 0 && user) {
          const fallback = await requestJson<SearchFallbackResponse>(
            `/search/books?q=${encodeURIComponent(query.trim())}&limit=12&withFallback=true`,
            {
              accessToken: tokenRef.current
            }
          );
          setBooks(fallback.data);
          setHasNextPage(false);
          setNextCursor(null);
          if (fallback.data.length > 0 && fallback.meta?.source && fallback.meta.source !== "local") {
            setMessage(`No local results. Imported from ${fallback.meta.source}.`);
          }
          return;
        }

        setBooks((previous) => (cursor ? [...previous, ...result.data] : result.data));
        setHasNextPage(result.pageInfo.hasNextPage);
        setNextCursor(result.pageInfo.nextCursor);
      } catch (error) {
        setMessage(parseApiError(error));
      } finally {
        setBooksLoading(false);
      }
    },
    [availableFilter, query, user]
  );

  const loadLibraryStats = useCallback(async () => {
    try {
      const result = await requestJson<LibraryStatsResponse>("/books/stats");
      setLibraryStats(result.data);
    } catch {
      setLibraryStats(null);
    }
  }, []);

  const loadLoans = useCallback(async () => {
    setLoansLoading(true);
    try {
      const result = await authRequest<{ data: Loan[] }>("/loans");
      setLoans(result.data);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setLoansLoading(false);
    }
  }, [authRequest]);

  const loadBorrowRequests = useCallback(async () => {
    if (!user) {
      setBorrowRequests([]);
      setMemberUnreadRequestCount(0);
      setAdminPendingRequestCount(0);
      return;
    }
    setBorrowRequestsLoading(true);
    try {
      const query =
        user.role === "ADMIN"
          ? "/borrow-requests?status=PENDING&limit=100"
          : "/borrow-requests?limit=100";
      const result = await authRequest<BorrowRequestsResponse>(query);
      setBorrowRequests(result.data);
      setMemberUnreadRequestCount(result.meta.unreadForMember ?? 0);
      setAdminPendingRequestCount(result.meta.pendingCount ?? 0);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setBorrowRequestsLoading(false);
    }
  }, [authRequest, user]);

  const loadRecommendations = useCallback(async () => {
    setRecommendationsLoading(true);
    try {
      const result = await requestJson<{ data: Book[] }>("/ai/recommendations", {
        method: "POST",
        body: { limit: 8 },
        accessToken: tokenRef.current
      });
      setRecommendations(result.data);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setRecommendationsLoading(false);
    }
  }, []);

  const loadFavoriteBooks = useCallback(async () => {
    if (!user) {
      setFavoriteBooks([]);
      return;
    }
    setFavoriteBooksLoading(true);
    try {
      const result = await authRequest<{ data: Book[] }>("/books/favorites?limit=12");
      setFavoriteBooks(result.data);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setFavoriteBooksLoading(false);
    }
  }, [authRequest, user]);

  const loadUsers = useCallback(async () => {
    if (user?.role !== "ADMIN") {
      return;
    }
    setAdminLoading(true);
    try {
      const result = await authRequest<{ data: User[] }>("/users");
      setUsers(result.data);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setAdminLoading(false);
    }
  }, [authRequest, user?.role]);

  const loadAdminOverview = useCallback(async () => {
    if (user?.role !== "ADMIN") {
      return;
    }
    setAdminOverviewLoading(true);
    try {
      const result = await authRequest<AdminLoansOverviewResponse>("/loans/admin/overview");
      setBorrowersOverview(result.data.borrowers);
      setOverdueLoans(result.data.overdueLoans);
      setOverdueUsersCount(result.data.overdueUsers);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setAdminOverviewLoading(false);
    }
  }, [authRequest, user?.role]);

  const refreshAfterLoanMutation = useCallback(
    async (options?: { includeRecommendations?: boolean }) => {
      const tasks: Array<Promise<unknown>> = [loadBooks(), loadLoans(), loadLibraryStats(), loadBorrowRequests()];
      if (user?.role === "ADMIN") {
        tasks.push(loadAdminOverview());
      }
      if ((options?.includeRecommendations ?? false) && shouldLoadRecommendations) {
        tasks.push(loadRecommendations());
      }
      await Promise.all(tasks);
    },
    [
      loadAdminOverview,
      loadBooks,
      loadBorrowRequests,
      loadLoans,
      loadRecommendations,
      loadLibraryStats,
      shouldLoadRecommendations,
      user?.role
    ]
  );

  const bootAuth = useCallback(async () => {
    let token = tokenRef.current;
    if (!token) {
      setUser(null);
      setAccessToken(null);
      setMessage("Browse the catalog. Sign in only when you want to borrow.");
      setBooting(false);
      return;
    }

    try {
      const me = await requestJson<{ user: User }>("/auth/me", { accessToken: token });
      setUser(me.user);
      setAccessToken(token);
      setMessage(`Welcome back, ${me.user.name}.`);
    } catch (error) {
      if (error instanceof ApiError && error.statusCode === 401) {
        try {
          token = await refreshAccessToken();
          const me = await requestJson<{ user: User }>("/auth/me", { accessToken: token });
          setUser(me.user);
          setAccessToken(token);
          setMessage(`Welcome back, ${me.user.name}.`);
          return;
        } catch {
          // fall through to guest mode
        }
      }
      setUser(null);
      setAccessToken(null);
      setMessage("Browse the catalog. Sign in only when you want to borrow.");
    } finally {
      setBooting(false);
    }
  }, [refreshAccessToken]);

  useEffect(() => {
    void bootAuth();
  }, [bootAuth]);

  useEffect(() => {
    if (booting) {
      return;
    }
    void Promise.all([loadBooks(), loadLibraryStats()]);
  }, [booting, loadBooks, loadLibraryStats]);

  useEffect(() => {
    if (!user) {
      setLoans([]);
      setBorrowRequests([]);
      setFavoriteBooks([]);
      setMemberUnreadRequestCount(0);
      setAdminPendingRequestCount(0);
      setUsers([]);
      setBorrowersOverview([]);
      setOverdueLoans([]);
      setOverdueUsersCount(0);
      setDueDateDrafts({});
      setShowDueSoonDetails(false);
      return;
    }
    void Promise.all([loadLoans(), loadBorrowRequests(), loadUsers(), loadAdminOverview(), loadFavoriteBooks()]);
  }, [loadAdminOverview, loadBorrowRequests, loadFavoriteBooks, loadLoans, loadUsers, user]);

  useEffect(() => {
    if (!user) {
      return;
    }
    const timer = window.setInterval(() => {
      void loadBorrowRequests();
    }, 25_000);
    return () => window.clearInterval(timer);
  }, [loadBorrowRequests, user]);

  useEffect(() => {
    if (booting || !shouldLoadRecommendations) {
      return;
    }
    void loadRecommendations();
  }, [booting, loadRecommendations, shouldLoadRecommendations, user?.id]);

  useEffect(() => {
    if (booting || !user || viewMode !== "dashboard") {
      return;
    }
    void Promise.all([loadRecommendations(), loadFavoriteBooks()]);
  }, [booting, loadFavoriteBooks, loadRecommendations, user, viewMode]);

  useEffect(() => {
    if (booting || shouldLoadRecommendations || viewMode !== "catalog") {
      return;
    }
    const section = document.getElementById("recommendations-section");
    if (!section) {
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries.some((entry) => entry.isIntersecting)) {
          setShouldLoadRecommendations(true);
          observer.disconnect();
        }
      },
      { rootMargin: "220px 0px" }
    );
    observer.observe(section);

    return () => observer.disconnect();
  }, [booting, shouldLoadRecommendations, viewMode, books.length]);

  useEffect(() => {
    if (!user) {
      setContactDraft({
        contactEmail: "",
        phoneNumber: "",
        personalId: ""
      });
      setAppearanceDraft({
        avatarPreset: defaultAvatarPresetId,
        backgroundPreset: defaultBackgroundPresetId
      });
      return;
    }
    setContactDraft({
      contactEmail: user.contactEmail ?? user.email,
      phoneNumber: user.phoneNumber ?? "",
      personalId: user.personalId ?? ""
    });
    setAppearanceDraft({
      avatarPreset: user.avatarPreset ?? defaultAvatarPresetId,
      backgroundPreset: user.backgroundPreset ?? defaultBackgroundPresetId
    });
  }, [user]);

  useEffect(() => {
    const preset = getBackgroundPreset(user?.backgroundPreset ?? defaultBackgroundPresetId);
    document.body.style.background = preset.background;
    document.body.style.color = user?.backgroundPreset === "bg-9" ? "#f1f5f9" : "";
  }, [user?.backgroundPreset]);

  const loginWithGoogleCredential = useCallback(async (credential: string) => {
    try {
      setSigningIn(true);
      setMessage("Signing in...");
      const result = await requestJson<AuthResponse>("/auth/google", {
        method: "POST",
        body: { credential }
      });
      setAccessToken(result.accessToken);
      setUser(result.user);
      setMessage(`Signed in as ${result.user.name}.`);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSigningIn(false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await requestJson<{ success: boolean }>("/auth/logout", { method: "POST" });
    } catch {
      // no-op for failed logout request
    } finally {
      setUser(null);
      setAccessToken(null);
      setViewMode("catalog");
      setShowDueSoonDetails(false);
      setShouldLoadRecommendations(false);
      setRecommendations([]);
      setBorrowRequests([]);
      setMemberUnreadRequestCount(0);
      setAdminPendingRequestCount(0);
      setActiveBookId(null);
      setBookDetails(null);
      if (window.location.pathname !== "/") {
        window.history.pushState({}, "", "/");
      }
      setMessage("Signed out.");
    }
  }, []);

  const activeLoans = useMemo(() => loans.filter((loan) => !loan.returnedAt), [loans]);
  const myActiveLoans = useMemo(() => {
    if (!user) {
      return [];
    }
    return activeLoans.filter((loan) => loan.userId === user.id);
  }, [activeLoans, user]);
  const canManageBooks = user?.role === "ADMIN";
  const canBorrow = !!user;
  const totalBooksCount = libraryStats?.totalBooks ?? books.length;
  const availableBooksCount = libraryStats?.availableBooks ?? books.filter((book) => book.available).length;
  const checkedOutBooksCount = libraryStats?.checkedOutBooks ?? Math.max(0, totalBooksCount - availableBooksCount);
  const dueSoonLoans = useMemo(() => {
    if (!user) {
      return [];
    }
    const now = new Date();
    const threshold = new Date(now);
    threshold.setDate(now.getDate() + 3);
    const sourceLoans =
      user.role === "ADMIN" ? activeLoans.filter((loan) => loan.user.role === "MEMBER") : myActiveLoans;
    return sourceLoans
      .filter((loan) => {
        if (!loan.dueAt) {
          return false;
        }
        const due = new Date(loan.dueAt);
        return due >= now && due <= threshold;
      })
      .sort((a, b) => {
        const left = a.dueAt ? new Date(a.dueAt).getTime() : Number.MAX_SAFE_INTEGER;
        const right = b.dueAt ? new Date(b.dueAt).getTime() : Number.MAX_SAFE_INTEGER;
        return left - right;
      });
  }, [activeLoans, myActiveLoans, user]);
  const dueSoonCount = dueSoonLoans.length;
  const pendingBorrowRequests = useMemo(
    () => borrowRequests.filter((request) => request.status === "PENDING"),
    [borrowRequests]
  );

  const openBookDetails = useCallback((bookId: string) => {
    if (window.location.pathname !== `/books/${bookId}`) {
      window.history.pushState({}, "", `/books/${bookId}`);
    }
    setActiveBookId(bookId);
    setPreviewBook(null);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }, []);

  const closeBookDetails = useCallback(() => {
    if (window.location.pathname !== "/") {
      window.history.pushState({}, "", "/");
    }
    setActiveBookId(null);
    setBookDetails(null);
    setShareFeedback("");
  }, []);

  const loadBookDetails = useCallback(
    async (bookId: string) => {
      setBookDetailsLoading(true);
      try {
        const result = await authRequest<BookDetailsResponse>(`/books/${bookId}/details`);
        setBookDetails(result.data);
        setReviewDraft({
          rating: result.data.myReview?.rating ? String(result.data.myReview.rating) : "5",
          content: result.data.myReview?.content ?? ""
        });
        setNoteDraft(result.data.myNote?.content ?? "");
      } catch (error) {
        setBookDetails(null);
        setMessage(parseApiError(error));
      } finally {
        setBookDetailsLoading(false);
      }
    },
    [authRequest]
  );

  useEffect(() => {
    const onPopState = () => {
      const pathBookId = getBookIdFromPath();
      setActiveBookId(pathBookId);
      if (!pathBookId) {
        setBookDetails(null);
        setShareFeedback("");
        setViewMode("catalog");
      }
    };

    window.addEventListener("popstate", onPopState);
    return () => window.removeEventListener("popstate", onPopState);
  }, []);

  useEffect(() => {
    if (!activeBookId) {
      return;
    }
    void loadBookDetails(activeBookId);
  }, [activeBookId, loadBookDetails]);

  const shareCurrentBook = useCallback(async () => {
    if (!bookDetails) {
      return;
    }
    const shareUrl = `${window.location.origin}/books/${bookDetails.book.id}`;
    try {
      if (navigator.share) {
        await navigator.share({
          title: `${bookDetails.book.title} | MLMS`,
          text: `Check this book: ${bookDetails.book.title} by ${bookDetails.book.author}`,
          url: shareUrl
        });
        setShareFeedback("Shared.");
        return;
      }
      await navigator.clipboard.writeText(shareUrl);
      setShareFeedback("Link copied.");
    } catch {
      setShareFeedback("Could not share right now.");
    }
  }, [bookDetails]);

  const saveBookReview = useCallback(async () => {
    if (!activeBookId) {
      return;
    }
    if (!user) {
      setMessage("Sign in with Google to write a review.");
      return;
    }
    try {
      const rating = Number(reviewDraft.rating);
      if (!Number.isFinite(rating) || rating < 1 || rating > 5) {
        setMessage("Rating must be between 1 and 5.");
        return;
      }
      if (!reviewDraft.content.trim()) {
        setMessage("Review content is required.");
        return;
      }
      setSavingReview(true);
      await authRequest(`/books/${activeBookId}/review`, {
        method: "PUT",
        body: {
          rating,
          content: reviewDraft.content.trim()
        }
      });
      setMessage("Review saved.");
      await loadBookDetails(activeBookId);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSavingReview(false);
    }
  }, [activeBookId, authRequest, loadBookDetails, reviewDraft.content, reviewDraft.rating, user]);

  const saveBookNote = useCallback(async () => {
    if (!activeBookId) {
      return;
    }
    if (!user) {
      setMessage("Sign in with Google to save private notes.");
      return;
    }
    try {
      if (!noteDraft.trim()) {
        setMessage("Note content is required.");
        return;
      }
      setSavingNote(true);
      await authRequest(`/books/${activeBookId}/note`, {
        method: "PUT",
        body: {
          content: noteDraft.trim()
        }
      });
      setMessage("Note saved.");
      await loadBookDetails(activeBookId);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSavingNote(false);
    }
  }, [activeBookId, authRequest, loadBookDetails, noteDraft, user]);

  const openUserDashboard = useCallback(() => {
    if (!user) {
      return;
    }
    closeBookDetails();
    if (viewMode !== "dashboard") {
      window.history.pushState({ mlmsView: "dashboard" }, "", window.location.pathname);
    }
    setViewMode("dashboard");
    window.scrollTo({ top: 0, behavior: "smooth" });
    if (user.role === "MEMBER") {
      void authRequest("/borrow-requests/me/mark-seen", { method: "POST" })
        .then(() => loadBorrowRequests())
        .catch(() => {
          // no-op: notification ack failure should not block dashboard
        });
    }
  }, [authRequest, closeBookDetails, loadBorrowRequests, user, viewMode]);

  const openUserSettings = useCallback(() => {
    if (!user) {
      return;
    }
    closeBookDetails();
    if (viewMode !== "settings") {
      window.history.pushState({ mlmsView: "settings" }, "", window.location.pathname);
    }
    setViewMode("settings");
    window.scrollTo({ top: 0, behavior: "smooth" });
  }, [closeBookDetails, user, viewMode]);

  const goHome = useCallback(() => {
    closeBookDetails();
    setViewMode("catalog");
    window.scrollTo({ top: 0, behavior: "smooth" });
  }, [closeBookDetails]);

  const scrollToRecommendations = useCallback(() => {
    setShouldLoadRecommendations(true);
    const target = document.getElementById("recommendations-section");
    if (!target) {
      return;
    }
    target.scrollIntoView({ behavior: "smooth", block: "start" });
  }, []);

  const ensureSignedIn = useCallback(
    (action: string) => {
      if (user) {
        return true;
      }
      setMessage(`Sign in with Google to ${action}.`);
      return false;
    },
    [user]
  );

  const toggleFavoriteBook = useCallback(
    async (bookId: string) => {
      if (!ensureSignedIn("manage favorites")) {
        return;
      }
      if (favoritePendingIds.includes(bookId)) {
        return;
      }

      try {
        setFavoritePendingIds((current) => [...current, bookId]);
        const result = await authRequest<FavoriteToggleResponse>(`/books/${bookId}/favorite/toggle`, {
          method: "POST"
        });
        const nextFavorite = result.data.isFavorite;

        const applyFavoriteState = (book: Book): Book =>
          book.id === bookId
            ? {
                ...book,
                isFavorite: nextFavorite
              }
            : book;

        setBooks((current) => current.map(applyFavoriteState));
        setRecommendations((current) => current.map(applyFavoriteState));
        setFavoriteBooks((current) => {
          if (nextFavorite) {
            const sourceBook =
              books.find((book) => book.id === bookId) ??
              recommendations.find((book) => book.id === bookId) ??
              bookDetails?.book;
            if (!sourceBook || current.some((book) => book.id === bookId)) {
              return current;
            }
            return [applyFavoriteState(sourceBook), ...current].slice(0, 12);
          }
          return current.filter((book) => book.id !== bookId);
        });
        setBookDetails((current) =>
          current
            ? {
                ...current,
                book: applyFavoriteState(current.book),
                relatedBooks: current.relatedBooks.map(applyFavoriteState)
              }
            : current
        );

        setMessage(nextFavorite ? "Added to favorites." : "Removed from favorites.");
        if (user) {
          void Promise.all([loadRecommendations(), loadFavoriteBooks()]);
        }
      } catch (error) {
        setMessage(parseApiError(error));
      } finally {
        setFavoritePendingIds((current) => current.filter((id) => id !== bookId));
      }
    },
    [authRequest, bookDetails?.book, books, ensureSignedIn, favoritePendingIds, loadFavoriteBooks, loadRecommendations, recommendations, user]
  );

  useEffect(() => {
    if (user?.role !== "ADMIN") {
      return;
    }
    if (overdueLoans.length > 0) {
      setMessage(
        `Overdue alert: ${overdueLoans.length} book(s) across ${overdueUsersCount} borrower(s) passed due date.`
      );
    }
  }, [overdueLoans.length, overdueUsersCount, user?.role]);

  const resetBookForm = () => {
    setBookForm(emptyBookForm);
    setEditingBookId(null);
    setShowBookEditor(false);
  };

  const submitBook = async () => {
    try {
      setSubmittingBook(true);
      const payload = {
        title: bookForm.title,
        author: bookForm.author,
        isbn: toNullableText(bookForm.isbn),
        genre: toNullableText(bookForm.genre),
        publishedYear: bookForm.publishedYear ? Number(bookForm.publishedYear) : null,
        description: toNullableText(bookForm.description),
        coverUrl: toNullableText(bookForm.coverUrl)
      };

      if (editingBookId) {
        await authRequest(`/books/${editingBookId}`, { method: "PATCH", body: payload });
        setMessage("Book updated.");
      } else {
        await authRequest("/books", { method: "POST", body: payload });
        setMessage("Book created.");
      }
      resetBookForm();
      await Promise.all([loadBooks(), loadLibraryStats()]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSubmittingBook(false);
    }
  };

  const editBook = (book: Book) => {
    setEditingBookId(book.id);
    setBookForm({
      title: book.title,
      author: book.author,
      isbn: book.isbn ?? "",
      genre: book.genre ?? "",
      publishedYear: book.publishedYear?.toString() ?? "",
      description: book.description ?? "",
      coverUrl: book.coverUrl ?? ""
    });
    setShowBookEditor(true);
  };

  const deleteBook = async (bookId: string) => {
    if (!window.confirm("Delete this book? This cannot be undone.")) {
      return;
    }
    try {
      await authRequest(`/books/${bookId}`, { method: "DELETE" });
      setMessage("Book deleted.");
      await Promise.all([loadBooks(), loadLibraryStats()]);
    } catch (error) {
      setMessage(parseApiError(error));
    }
  };

  const checkoutBook = async (bookId: string) => {
    if (!ensureSignedIn("borrow books")) {
      return;
    }
    if (checkoutPendingIds.includes(bookId)) {
      return;
    }
    try {
      setCheckoutPendingIds((current) => [...current, bookId]);
      if (user?.role === "ADMIN") {
        setMessage("Borrowing book...");
        await authRequest("/loans/checkout", {
          method: "POST",
          body: { bookId }
        });

        // Optimistic local update for instant feedback.
        setBooks((current) =>
          current.map((book) => (book.id === bookId ? { ...book, available: false, requestPending: false } : book))
        );
        setLibraryStats((current) =>
          current
            ? {
                ...current,
                availableBooks: Math.max(0, current.availableBooks - 1),
                checkedOutBooks: current.checkedOutBooks + 1,
                activeLoans: current.activeLoans + 1
              }
            : current
        );
        setRecommendations((current) =>
          current.map((book) => (book.id === bookId ? { ...book, available: false, requestPending: false } : book))
        );
        setMessage("Book checked out (borrowed).");
      } else {
        setMessage("Submitting borrow request...");
        await authRequest("/borrow-requests", {
          method: "POST",
          body: { bookId }
        });
        setBooks((current) =>
          current.map((book) => (book.id === bookId ? { ...book, requestPending: true } : book))
        );
        setRecommendations((current) =>
          current.map((book) => (book.id === bookId ? { ...book, requestPending: true } : book))
        );
        setMessage("Borrow request submitted. Waiting for admin approval.");
      }
      void refreshAfterLoanMutation({ includeRecommendations: false });
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setCheckoutPendingIds((current) => current.filter((id) => id !== bookId));
    }
  };

  const approveBorrowRequest = async (requestId: string) => {
    try {
      setBorrowRequestActionId(requestId);
      await authRequest(`/borrow-requests/${requestId}/approve`, { method: "POST" });
      setMessage("Borrow request approved.");
      await Promise.all([loadBorrowRequests(), refreshAfterLoanMutation({ includeRecommendations: false })]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setBorrowRequestActionId(null);
    }
  };

  const declineBorrowRequest = async (requestId: string) => {
    try {
      setBorrowRequestActionId(requestId);
      await authRequest(`/borrow-requests/${requestId}/decline`, { method: "POST" });
      setMessage("Borrow request declined.");
      await Promise.all([loadBorrowRequests(), refreshAfterLoanMutation({ includeRecommendations: false })]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setBorrowRequestActionId(null);
    }
  };

  const checkinBook = async (bookId: string) => {
    try {
      const response = await authRequest<{ data: Loan; meta?: { awardedPoints?: number } }>("/loans/checkin", {
        method: "POST",
        body: { bookId }
      });
      if (user && response.data.userId === user.id) {
        setUser((current) =>
          current
            ? {
                ...current,
                readingPoints: response.data.user.readingPoints
              }
            : current
        );
      }
      const pointsLabel =
        response.meta?.awardedPoints && response.meta.awardedPoints > 0
          ? ` +${response.meta.awardedPoints} XP`
          : "";
      setMessage(`Book checked in (returned).${pointsLabel}`);
      // Background sync (does not block UI response).
      void refreshAfterLoanMutation({ includeRecommendations: false });
    } catch (error) {
      setMessage(parseApiError(error));
    }
  };

  const updateUserRole = async (userId: string, role: Role) => {
    try {
      await authRequest(`/users/${userId}/role`, {
        method: "PATCH",
        body: { role }
      });
      setMessage("User role updated.");
      await loadUsers();
    } catch (error) {
      setMessage(parseApiError(error));
    }
  };

  const saveMyContactProfile = async () => {
    try {
      if (!contactDraft.contactEmail.trim()) {
        setMessage("Contact email is required.");
        return;
      }
      if (!contactDraft.phoneNumber.trim()) {
        setMessage("Phone number is required.");
        return;
      }
      setSavingContact(true);
      const result = await authRequest<UpdateContactResponse>("/users/me/contact", {
        method: "PATCH",
        body: {
          contactEmail: contactDraft.contactEmail.trim(),
          phoneNumber: contactDraft.phoneNumber.trim(),
          personalId: toNullableText(contactDraft.personalId)
        }
      });
      setUser((current) => (current ? result.data : current));
      setMessage("Contact profile updated.");
      if (user?.role === "ADMIN") {
        await loadUsers();
      }
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSavingContact(false);
    }
  };

  const updateLoanDueDate = async (loan: Loan) => {
    const dueDate = dueDateDrafts[loan.id] ?? toDateInputValue(loan.dueAt);
    if (!dueDate) {
      setMessage("Select a due date before saving.");
      return;
    }

    try {
      setDueDateUpdatingId(loan.id);
      await authRequest<{ data: Loan }>(`/loans/${loan.id}/due-date`, {
        method: "PATCH",
        body: {
          dueAt: new Date(`${dueDate}T12:00:00.000Z`).toISOString()
        }
      });
      setMessage("Loan due date updated.");
      await Promise.all([loadLoans(), loadAdminOverview()]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setDueDateUpdatingId(null);
    }
  };

  const importFromExternal = async () => {
    try {
      setImportingExternal(true);
      const limitNumber = Number(importLimit);
      if (!Number.isFinite(limitNumber) || limitNumber < 1 || limitNumber > 300) {
        setMessage("Import limit must be between 1 and 300.");
        return;
      }
      const enrichLimitNumber = Number(enrichLimit);
      const coreEnrichLimit =
        Number.isFinite(enrichLimitNumber) && enrichLimitNumber >= 1 && enrichLimitNumber <= 500
          ? enrichLimitNumber
          : Math.min(500, Math.max(limitNumber, 100));

      const response = await authRequest<SearchFallbackResponse>("/books/import/external", {
        method: "POST",
        body: {
          query: importQuery,
          limit: limitNumber,
          provider: importProvider
        }
      });

      const importedCount = response.meta?.importedCount ?? response.data.length;
      const existingCount = response.meta?.existingCount ?? 0;
      setMessage(
        `Import finished from ${importProvider}. Added ${importedCount} new books, reused ${existingCount}. Running core auto-fill...`
      );

      setEnrichingCoreMetadata(true);
      const coreResponse = await authRequest<EnrichCoreMetadataResponse>("/books/enrich-core-metadata", {
        method: "POST",
        body: {
          limit: coreEnrichLimit,
          provider: importProvider
        }
      });

      setMessage(
        `Import + core auto-fill done (${coreResponse.meta.providerUsed}). Added ${importedCount}, reused ${existingCount}, core-updated ${coreResponse.meta.updatedCount}/${coreResponse.meta.processed}.`
      );
      await Promise.all([loadBooks(), loadLibraryStats(), loadRecommendations()]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setImportingExternal(false);
      setEnrichingCoreMetadata(false);
    }
  };

  const saveAppearancePreferences = async () => {
    try {
      setSavingAppearance(true);
      const result = await authRequest<UpdateContactResponse>("/users/me/preferences", {
        method: "PATCH",
        body: {
          avatarPreset: appearanceDraft.avatarPreset,
          backgroundPreset: appearanceDraft.backgroundPreset
        }
      });
      setUser((current) => (current ? result.data : current));
      setMessage("Appearance updated.");
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setSavingAppearance(false);
    }
  };

  const enrichLibraryMetadata = async () => {
    try {
      setEnrichingMetadata(true);
      const limitNumber = Number(enrichLimit);
      if (!Number.isFinite(limitNumber) || limitNumber < 1 || limitNumber > 500) {
        setMessage("Enrichment limit must be between 1 and 500.");
        return;
      }

      const response = await authRequest<EnrichMetadataResponse>("/books/enrich-metadata", {
        method: "POST",
        body: {
          limit: limitNumber,
          provider: importProvider,
          onlyMissing: true
        }
      });

      setMessage(
        `Enrichment done (${response.meta.providerUsed}). Updated ${response.meta.updatedCount}/${response.meta.processed}, unmatched ${response.meta.noMatchCount}, failed ${response.meta.failedCount}.`
      );
      await Promise.all([loadBooks(), loadLibraryStats()]);
    } catch (error) {
      setMessage(parseApiError(error));
    } finally {
      setEnrichingMetadata(false);
    }
  };

  if (booting) {
    return (
      <main className="auth-shell">
        <section className="auth-card">
          <h1>Starting MLMS...</h1>
          <p className="muted">Loading user session and secure API state.</p>
        </section>
      </main>
    );
  }

  return (
    <>
      <a className="skip-link" href="#main-content">
        Skip to main content
      </a>
      <header className="topbar">
        <div className="topbar-title">
          <h1>{user ? `Hi, ${user.name}` : "Browse the public catalog"}</h1>
        </div>
        <ProfileMenu
          user={user}
          busy={signingIn}
          borrowedCount={myActiveLoans.length}
          adminPendingCount={adminPendingRequestCount}
          memberUnreadRequestCount={memberUnreadRequestCount}
          onGoogleCredential={loginWithGoogleCredential}
          onLogout={logout}
          onOpenDashboard={openUserDashboard}
          onOpenSettings={openUserSettings}
        />
      </header>

      <main id="main-content" className="page">
        {(activeBookId || viewMode !== "catalog") && (
          <div className="context-back-row">
            <button className="btn btn-outline back-arrow-btn" type="button" onClick={goHome} aria-label="Back to home">
              <span aria-hidden="true">â†</span>
              <span>Home</span>
            </button>
          </div>
        )}
        {activeBookId ? (
          <section className="panel book-detail-page" aria-labelledby="book-detail-title">
            <div className="panel-head book-detail-head">
              <button
                className="btn btn-outline"
                type="button"
                onClick={goHome}
              >
                Back to Home
              </button>
            </div>

            {bookDetailsLoading && <p className="muted">Loading book details...</p>}
            {!bookDetailsLoading && !bookDetails && (
              <p className="muted">Book details could not be loaded. Go back to Home and try again.</p>
            )}

            {!bookDetailsLoading && bookDetails && (
              <>
                <section className="book-detail-hero">
                  <BookCover book={bookDetails.book} className="book-cover-large" />
                  <div className="book-detail-summary">
                    <div className="title-row">
                      <h2 id="book-detail-title">{bookDetails.book.title}</h2>
                      <AiMetadataBadge book={bookDetails.book} />
                    </div>
                    <p className="muted detail-author">{bookDetails.book.author}</p>
                    <BookRating book={bookDetails.book} />
                    <p className="muted">
                      Community rating:{" "}
                      {bookDetails.reviewSummary.averageRating !== null
                        ? `${bookDetails.reviewSummary.averageRating.toFixed(1)} (${bookDetails.reviewSummary.count})`
                        : "No community reviews yet"}
                    </p>
                    <p
                      className={`status-pill ${
                        bookDetails.book.requestPending ? "pending" : bookDetails.book.available ? "available" : "unavailable"
                      }`}
                    >
                      {bookDetails.book.requestPending
                        ? "Pending approval"
                        : bookDetails.book.available
                          ? "Checked in (returned)"
                          : "Checked out (borrowed)"}
                    </p>
                    <p className="book-detail-description">
                      {bookDetails.book.description ?? "No summary available for this book yet."}
                    </p>
                    <div className="book-detail-meta">
                      <p>
                        <strong>Genre:</strong> {bookDetails.book.genre ?? "Uncategorized"}
                      </p>
                      <p>
                        <strong>Published:</strong> {bookDetails.book.publishedYear ?? "Unknown"}
                      </p>
                      <p>
                        <strong>ISBN:</strong> {bookDetails.book.isbn ?? "N/A"}
                      </p>
                    </div>
                    <div className="row-actions">
                      <FavoriteStarButton
                        bookId={bookDetails.book.id}
                        isFavorite={bookDetails.book.isFavorite}
                        isPending={favoritePendingIds.includes(bookDetails.book.id)}
                        onToggle={toggleFavoriteBook}
                      />
                      <button className="btn btn-outline" type="button" onClick={() => void shareCurrentBook()}>
                        Share link
                      </button>
                      {bookDetails.book.available ? (
                        (() => {
                          const isPending = checkoutPendingIds.includes(bookDetails.book.id);
                          const hasPendingRequest = bookDetails.book.requestPending;
                          const actionLabel = hasPendingRequest ? "Pending" : user?.role === "ADMIN" ? "Borrow" : "Request";
                          return (
                            <button
                              className={`btn${isPending ? " is-loading" : ""}`}
                              type="button"
                              onClick={() => void checkoutBook(bookDetails.book.id)}
                              disabled={!canBorrow || isPending || hasPendingRequest}
                              aria-busy={isPending}
                              aria-label={
                                hasPendingRequest
                                  ? "Book has a pending request"
                                  : isPending
                                    ? "Request in progress"
                                    : canBorrow
                                      ? actionLabel
                                      : "Sign in"
                              }
                            >
                              {hasPendingRequest ? "Pending" : canBorrow ? actionLabel : "Sign in"}
                            </button>
                          );
                        })()
                      ) : (
                        <span className="muted">This book is currently checked out (borrowed).</span>
                      )}
                      {shareFeedback && <p className="muted">{shareFeedback}</p>}
                    </div>
                  </div>
                </section>

                <section className="book-interaction-grid" aria-label="Book interactions">
                  <article className="panel">
                    <h3>My private note</h3>
                    {!user && <p className="muted">Sign in to save personal notes.</p>}
                    {user && (
                      <>
                        <p className="muted">Saved under your account ({user.email}).</p>
                        <textarea
                          rows={6}
                          maxLength={3000}
                          value={noteDraft}
                          onChange={(event) => setNoteDraft(event.target.value)}
                          placeholder="Write your personal note for this book..."
                        />
                        <div className="row-actions">
                          <button className="btn" type="button" onClick={() => void saveBookNote()} disabled={savingNote}>
                            {savingNote ? "Saving..." : "Save note"}
                          </button>
                        </div>

                        <h3>Your review</h3>
                        <div className="review-editor">
                          <label>
                            Your rating
                            <select
                              value={reviewDraft.rating}
                              onChange={(event) =>
                                setReviewDraft((current) => ({ ...current, rating: event.target.value }))
                              }
                            >
                              <option value="5">5</option>
                              <option value="4">4</option>
                              <option value="3">3</option>
                              <option value="2">2</option>
                              <option value="1">1</option>
                            </select>
                          </label>
                          <label>
                            Your review
                            <textarea
                              rows={4}
                              maxLength={1500}
                              value={reviewDraft.content}
                              onChange={(event) =>
                                setReviewDraft((current) => ({ ...current, content: event.target.value }))
                              }
                              placeholder="Write your review..."
                            />
                          </label>
                          <div className="row-actions">
                            <button className="btn" type="button" onClick={() => void saveBookReview()} disabled={savingReview}>
                              {savingReview ? "Saving..." : "Save review"}
                            </button>
                          </div>
                        </div>
                      </>
                    )}
                  </article>

                  <article className="panel">
                    <h3>Reviews</h3>
                    <p className="muted">All member reviews with rating and review text.</p>

                    <ul className="stack-list reviews-list">
                      {bookDetails.reviews.length === 0 && <li className="muted">No reviews yet.</li>}
                      {bookDetails.reviews.map((review) => (
                        <li key={review.id} className="row-item review-item">
                          <div>
                            <p className="review-head">
                              <strong>{review.user.name}</strong>
                              <span>{`L${getLevelInfo(review.user.readingPoints).levelNumber}`}</span>
                            </p>
                            <p className="review-rating-line">{`Rating: ${review.rating}/5`}</p>
                            <p className="review-text">{review.content}</p>
                            <p className="muted">Updated {new Date(review.updatedAt).toLocaleDateString()}</p>
                          </div>
                        </li>
                      ))}
                    </ul>
                  </article>
                </section>

                <section className="panel" aria-labelledby="related-books-title">
                  <div className="panel-head">
                    <h3 id="related-books-title">Suggested books by author or genre</h3>
                  </div>
                  <div className="book-grid related-book-grid">
                    {bookDetails.relatedBooks.length === 0 && (
                      <p className="muted">No related books found yet.</p>
                    )}
                    {bookDetails.relatedBooks.map((relatedBook) => (
                      <article
                        key={relatedBook.id}
                        className="book-card storefront-book-card clickable-card"
                        role="button"
                        tabIndex={0}
                        aria-label={`Open details for ${relatedBook.title}`}
                        onClick={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          openBookDetails(relatedBook.id);
                        }}
                        onKeyDown={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          if (event.key === "Enter" || event.key === " ") {
                            event.preventDefault();
                            openBookDetails(relatedBook.id);
                          }
                        }}
                      >
                        <div className="book-card-head storefront-book-head">
                          <BookCover book={relatedBook} className="book-cover-thumb" />
                          <header>
                            <h3 className="book-title" title={relatedBook.title}>
                              {truncateText(relatedBook.title, 90)}
                            </h3>
                            <div className="book-card-subhead">
                              <p className="muted">{relatedBook.author}</p>
                              <div className="title-row-icons">
                                <AiMetadataBadge book={relatedBook} />
                                <FavoriteStarButton
                                  bookId={relatedBook.id}
                                  isFavorite={relatedBook.isFavorite}
                                  isPending={favoritePendingIds.includes(relatedBook.id)}
                                  onToggle={toggleFavoriteBook}
                                />
                              </div>
                            </div>
                            <BookRating book={relatedBook} />
                          </header>
                        </div>
                        <p
                          className={`status-pill ${
                            relatedBook.requestPending ? "pending" : relatedBook.available ? "available" : "unavailable"
                          }`}
                        >
                          {relatedBook.requestPending
                            ? "Pending approval"
                            : relatedBook.available
                              ? "Checked in (returned)"
                              : "Checked out (borrowed)"}
                        </p>
                        <p className="book-genre">{truncateText(relatedBook.genre ?? "Uncategorized", 80)}</p>
                      </article>
                    ))}
                  </div>
                </section>
              </>
            )}
          </section>
        ) : (
          <>
        {viewMode === "catalog" && (
          <>
            {user && (
              <section className="catalog-head-cards" aria-label="Catalog summary">
                <article className="panel catalog-head-card">
                  <h3>Due soon</h3>
                  <button
                    className="catalog-head-value-btn"
                    type="button"
                    onClick={() => setShowDueSoonDetails((current) => !current)}
                    aria-expanded={showDueSoonDetails}
                    aria-controls="due-soon-list"
                  >
                    <span className="catalog-head-value">{`${dueSoonCount} book${dueSoonCount === 1 ? "" : "s"}`}</span>
                  </button>
                </article>
                <article className="panel catalog-head-card">
                  <h3>My loans</h3>
                  <p className="catalog-head-value">{`${myActiveLoans.length} active`}</p>
                </article>
                <article className="panel catalog-head-card">
                  <h3>
                    <span className="desktop-label">Recommendations</span>
                    <span className="compact-label">Picks</span>
                  </h3>
                  <button className="catalog-head-value-btn" type="button" onClick={scrollToRecommendations}>
                    <span className="catalog-head-value">{recommendations.length} picks</span>
                  </button>
                </article>
              </section>
            )}

            {user && showDueSoonDetails && (
              <section className="panel due-soon-panel" id="due-soon-list" aria-label="Due soon list">
                <div className="panel-head">
                  <h2>{user.role === "ADMIN" ? "Members due soon" : "Your due soon books"}</h2>
                </div>
                <ul className="stack-list">
                  {dueSoonLoans.length === 0 && <li className="muted">No books are due in the next 3 days.</li>}
                  {dueSoonLoans.map((loan) => (
                    <li key={loan.id} className="row-item">
                      <div>
                        <strong title={loan.book.title}>{truncateText(loan.book.title, 110)}</strong>
                        <p className="muted">
                          Due: {loan.dueAt ? new Date(loan.dueAt).toLocaleDateString() : "Not set"}
                        </p>
                        {user.role === "ADMIN" && (
                          <p className="muted">
                            {loan.user.name} | {loan.user.phoneNumber ?? "No phone"} |{" "}
                            {loan.user.contactEmail ?? loan.user.email}
                          </p>
                        )}
                      </div>
                    </li>
                  ))}
                </ul>
              </section>
            )}

            <section className="catalog-workspace">
              <aside className="panel catalog-sidebar" aria-label="Quick filters">
                  <article className="catalog-total-books">
                    <p className="eyebrow">Library inventory</p>
                    <h2>{availableBooksCount} books available</h2>
                    <p className="muted">
                      {totalBooksCount} total | {checkedOutBooksCount} checked out (borrowed)
                    </p>
                  </article>

                <form
                  className="filters catalog-filters"
                  onSubmit={(event) => {
                    event.preventDefault();
                    void loadBooks();
                  }}
                >
                  <label className="filter-search-label">
                    <span className="desktop-label">Search by title, author, genre, ISBN</span>
                    <span className="compact-label">Search</span>
                    <input value={query} onChange={(event) => setQuery(event.target.value)} name="q" />
                  </label>

                  <label className="filter-availability-label">
                    Availability
                    <select value={availableFilter} onChange={(event) => setAvailableFilter(event.target.value)}>
                      <option value="all">All</option>
                      <option value="available">Checked in (returned)</option>
                      <option value="unavailable">Checked out (borrowed)</option>
                    </select>
                  </label>

                  <button className="btn" type="submit" disabled={booksLoading}>
                    {booksLoading ? "Searching..." : "Apply filters"}
                  </button>
                </form>

                {canManageBooks && (
                  <button
                    className="btn btn-outline catalog-admin-toggle"
                    type="button"
                    onClick={() => {
                      setShowBookEditor((value) => !value);
                      if (showBookEditor) {
                        resetBookForm();
                      }
                    }}
                  >
                    {showBookEditor ? "Close editor" : "Add a book"}
                  </button>
                )}
              </aside>

              <section className="catalog-main">
                {showBookEditor && canManageBooks && (
                  <section className="editor" aria-labelledby="editor-title">
                    <h3 id="editor-title">{editingBookId ? "Edit book" : "Add new book"}</h3>
                    <div className="editor-grid">
                      <label>
                        Title
                        <input
                          value={bookForm.title}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, title: event.target.value }))}
                          required
                        />
                      </label>
                      <label>
                        Author
                        <input
                          value={bookForm.author}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, author: event.target.value }))}
                          required
                        />
                      </label>
                      <label>
                        ISBN
                        <input
                          value={bookForm.isbn}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, isbn: event.target.value }))}
                        />
                      </label>
                      <label>
                        Genre
                        <input
                          value={bookForm.genre}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, genre: event.target.value }))}
                        />
                      </label>
                      <label>
                        Published year
                        <input
                          type="number"
                          min={0}
                          max={2100}
                          value={bookForm.publishedYear}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, publishedYear: event.target.value }))}
                        />
                      </label>
                      <label>
                        Cover URL
                        <input
                          type="url"
                          value={bookForm.coverUrl}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, coverUrl: event.target.value }))}
                        />
                      </label>
                      <label className="full-width">
                        Description
                        <textarea
                          rows={3}
                          value={bookForm.description}
                          onChange={(event) => setBookForm((prev) => ({ ...prev, description: event.target.value }))}
                        />
                      </label>
                    </div>
                    <div className="row-actions">
                      <button className="btn" type="button" disabled={submittingBook} onClick={() => void submitBook()}>
                        {submittingBook ? "Saving..." : editingBookId ? "Save changes" : "Create book"}
                      </button>
                      <button className="btn btn-outline" type="button" onClick={resetBookForm}>
                        Cancel
                      </button>
                    </div>
                  </section>
                )}

                <section className="panel" aria-labelledby="books-title">
                  <div className="panel-head">
                    <h2 id="books-title">Books</h2>
                  </div>

                  {booksLoading && books.length === 0 && <p className="muted">Loading books...</p>}
                  {!booksLoading && books.length === 0 && (
                    <p className="muted">No books found for this filter. Try another search term.</p>
                  )}

                  <div className="book-grid storefront-grid">
                    {books.map((book) => (
                      <article
                        className="book-card storefront-book-card clickable-card"
                        key={book.id}
                        role="button"
                        tabIndex={0}
                        aria-label={`Open details for ${book.title}`}
                        onClick={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          openBookDetails(book.id);
                        }}
                        onKeyDown={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          if (event.key === "Enter" || event.key === " ") {
                            event.preventDefault();
                            openBookDetails(book.id);
                          }
                        }}
                      >
                        <div className="book-card-head storefront-book-head">
                          <BookCover book={book} className="book-cover-thumb" />
                          <header>
                            <h3 className="book-title" title={book.title}>
                              {truncateText(book.title, 120)}
                            </h3>
                            <div className="book-card-subhead">
                              <p className="muted">{book.author}</p>
                              <div className="title-row-icons">
                                <AiMetadataBadge book={book} />
                                <FavoriteStarButton
                                  bookId={book.id}
                                  isFavorite={book.isFavorite}
                                  isPending={favoritePendingIds.includes(book.id)}
                                  onToggle={toggleFavoriteBook}
                                />
                              </div>
                            </div>
                            <BookRating book={book} />
                          </header>
                        </div>
                        <p
                          className={`status-pill ${
                            book.requestPending ? "pending" : book.available ? "available" : "unavailable"
                          }`}
                        >
                          {book.requestPending
                            ? "Pending approval"
                            : book.available
                              ? "Checked in (returned)"
                              : "Checked out (borrowed)"}
                        </p>
                        <p className="book-genre">{truncateText(book.genre ?? "Uncategorized", 80)}</p>
                        <p className="muted clamp-3">
                          {truncateText(
                            book.description ?? "No description yet. Click Preview to view more details.",
                            110
                          )}
                        </p>
                        <div className="row-actions book-card-actions">
                          <button className="btn btn-outline" type="button" onClick={() => setPreviewBook(book)}>
                            Preview
                          </button>
                          {book.available ? (
                            (() => {
                              const isPending = checkoutPendingIds.includes(book.id);
                              const hasPendingRequest = book.requestPending;
                              const actionLabel = hasPendingRequest ? "Pending" : user?.role === "ADMIN" ? "Borrow" : "Request";
                              return (
                                <button
                                  className={`btn${isPending ? " is-loading" : ""}`}
                                  type="button"
                                  onClick={() => void checkoutBook(book.id)}
                                  disabled={!canBorrow || isPending || hasPendingRequest}
                                  aria-busy={isPending}
                                  aria-label={
                                    hasPendingRequest
                                      ? "Book has a pending request"
                                      : isPending
                                        ? "Request in progress"
                                        : canBorrow
                                          ? actionLabel
                                          : "Sign in"
                                  }
                                >
                                  {hasPendingRequest ? "Pending" : canBorrow ? actionLabel : "Sign in"}
                                </button>
                              );
                            })()
                          ) : (
                            <span className="muted">Currently checked out (borrowed)</span>
                          )}
                          {canManageBooks && (
                            <>
                              <button className="btn btn-outline" type="button" onClick={() => editBook(book)}>
                                Edit
                              </button>
                              <button className="btn btn-danger" type="button" onClick={() => void deleteBook(book.id)}>
                                Delete
                              </button>
                            </>
                          )}
                        </div>
                      </article>
                    ))}
                  </div>

                  {hasNextPage && (
                    <button
                      className="btn btn-outline load-more-btn"
                      type="button"
                      onClick={() => void loadBooks(nextCursor)}
                      disabled={!nextCursor}
                    >
                      Load more
                    </button>
                  )}
                </section>

                <section id="recommendations-section" className="panel shelf-panel" aria-labelledby="ai-title">
                  <div className="panel-head">
                    <h2 id="ai-title">{user ? "Recommended for you" : "Popular picks"}</h2>
                  </div>
                  {!shouldLoadRecommendations && <p className="muted">Recommendations will load when you reach this section.</p>}
                  {shouldLoadRecommendations && recommendationsLoading && <p className="muted">Updating recommendations...</p>}
                  <div className="recommendation-shelf" role="list">
                  {shouldLoadRecommendations && recommendations.length === 0 && (
                    <p className="muted">
                      <span className="desktop-label">No recommendations yet.</span>
                      <span className="compact-label">No picks yet.</span>
                    </p>
                  )}
                    {recommendations.map((book) => (
                      <article
                        key={book.id}
                        className="shelf-card clickable-card"
                        role="listitem"
                        tabIndex={0}
                        aria-label={`Open details for ${book.title}`}
                        onClick={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          openBookDetails(book.id);
                        }}
                        onKeyDown={(event) => {
                          if (isInteractiveTarget(event.target)) {
                            return;
                          }
                          if (event.key === "Enter" || event.key === " ") {
                            event.preventDefault();
                            openBookDetails(book.id);
                          }
                        }}
                      >
                        <BookCover book={book} className="book-cover-thumb shelf-cover" />
                        <h3 className="shelf-title" title={book.title}>
                          {truncateText(book.title, 100)}
                        </h3>
                        <div className="book-card-subhead">
                          <p className="muted shelf-author" title={book.author}>
                            {truncateText(book.author, 70)}
                          </p>
                          <div className="title-row-icons">
                            <AiMetadataBadge book={book} />
                            <FavoriteStarButton
                              bookId={book.id}
                              isFavorite={book.isFavorite}
                              isPending={favoritePendingIds.includes(book.id)}
                              onToggle={toggleFavoriteBook}
                            />
                          </div>
                        </div>
                        <BookRating book={book} />
                        <p className="muted clamp-2 shelf-genre" title={book.genre ?? "General"}>
                          {truncateText(book.genre ?? "General", 100)}
                        </p>
                        {book.available && (
                          (() => {
                            const isPending = checkoutPendingIds.includes(book.id);
                            const hasPendingRequest = book.requestPending;
                            const actionLabel = hasPendingRequest ? "Pending" : user?.role === "ADMIN" ? "Borrow" : "Request";
                            return (
                              <button
                                className={`btn shelf-btn${isPending ? " is-loading" : ""}`}
                                type="button"
                                onClick={() => void checkoutBook(book.id)}
                                disabled={!canBorrow || isPending || hasPendingRequest}
                                aria-busy={isPending}
                                aria-label={
                                  hasPendingRequest
                                    ? "Book has a pending request"
                                    : isPending
                                      ? "Request in progress"
                                      : canBorrow
                                        ? actionLabel
                                        : "Sign in"
                                }
                              >
                                {hasPendingRequest ? "Pending" : canBorrow ? actionLabel : "Sign in"}
                              </button>
                            );
                          })()
                        )}
                        {!book.available && <p className="muted shelf-status">Checked out (borrowed)</p>}
                        {book.available && book.requestPending && <p className="muted shelf-status">Pending approval</p>}
                      </article>
                    ))}
                  </div>
                </section>
              </section>
            </section>
          </>
        )}

        {viewMode === "dashboard" && user && (
          <>
            <section className="panel two-col">
              <section id="loans-section" aria-labelledby="loans-title">
                <div className="panel-head">
                  <h2 id="loans-title">Active loans</h2>
                </div>
                {loansLoading && <p className="muted">Updating loans...</p>}
                <ul className="stack-list">
                  {activeLoans.length === 0 && <li className="muted">No active loans.</li>}
                  {activeLoans.map((loan) => (
                    <li key={loan.id} className="row-item">
                      <div>
                        <strong>{loan.book.title}</strong>
                        <p className="muted">
                          Borrowed by {loan.user.name} (L{getLevelInfo(loan.user.readingPoints).levelNumber}) on{" "}
                          {new Date(loan.checkedOutAt).toLocaleDateString()}
                        </p>
                        <p className={loan.dueAt && new Date(loan.dueAt) < new Date() ? "overdue-text" : "muted"}>
                          Due: {loan.dueAt ? new Date(loan.dueAt).toLocaleDateString() : "Not set"}
                        </p>
                      </div>
                      <div className="row-actions">
                        {user.role === "ADMIN" && (
                          <>
                            <input
                              type="date"
                              value={dueDateDrafts[loan.id] ?? toDateInputValue(loan.dueAt)}
                              onChange={(event) =>
                                setDueDateDrafts((current) => ({ ...current, [loan.id]: event.target.value }))
                              }
                              aria-label={`Due date for ${loan.book.title}`}
                            />
                            <button
                              className="btn btn-outline"
                              type="button"
                              onClick={() => void updateLoanDueDate(loan)}
                              disabled={dueDateUpdatingId === loan.id}
                            >
                              {dueDateUpdatingId === loan.id ? "Saving..." : "Save due date"}
                            </button>
                          </>
                        )}
                        <button className="btn btn-outline" type="button" onClick={() => void checkinBook(loan.bookId)}>
                          Check in
                        </button>
                      </div>
                    </li>
                  ))}
                </ul>
              </section>

              <section aria-labelledby="borrow-requests-title">
                <div className="panel-head">
                  <h2 id="borrow-requests-title">
                    {user.role === "ADMIN" ? "Pending borrow requests" : "My request updates"}
                  </h2>
                  <button
                    className="btn btn-outline"
                    type="button"
                    onClick={() => void loadBorrowRequests()}
                    disabled={borrowRequestsLoading}
                  >
                    {borrowRequestsLoading ? "Refreshing..." : "Refresh"}
                  </button>
                </div>
                {user.role === "ADMIN" ? (
                  <ul className="stack-list">
                    {pendingBorrowRequests.length === 0 && <li className="muted">No pending requests.</li>}
                    {pendingBorrowRequests.map((request) => (
                      <li key={request.id} className="row-item">
                        <div>
                          <strong>{request.book.title}</strong>
                          <p className="muted">
                            Requested by {request.user.name} on {new Date(request.createdAt).toLocaleDateString()}
                          </p>
                          <p className="muted">{`Borrower level: L${getLevelInfo(request.user.readingPoints).levelNumber}`}</p>
                        </div>
                        <div className="row-actions">
                          <button
                            className="btn"
                            type="button"
                            disabled={borrowRequestActionId === request.id}
                            onClick={() => void approveBorrowRequest(request.id)}
                          >
                            {borrowRequestActionId === request.id ? "Working..." : "Approve"}
                          </button>
                          <button
                            className="btn btn-outline"
                            type="button"
                            disabled={borrowRequestActionId === request.id}
                            onClick={() => void declineBorrowRequest(request.id)}
                          >
                            Decline
                          </button>
                        </div>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <ul className="stack-list">
                    {borrowRequests.length === 0 && <li className="muted">No borrow requests yet.</li>}
                    {borrowRequests.map((request) => (
                      <li key={request.id} className="row-item">
                        <div>
                          <strong>{request.book.title}</strong>
                          <p className="muted">{`Requested on ${new Date(request.createdAt).toLocaleDateString()}`}</p>
                          <p
                            className={
                              request.status === "DECLINED"
                                ? "overdue-text"
                                : request.status === "APPROVED"
                                  ? "notice"
                                  : "muted"
                            }
                          >
                            Status: {request.status}
                          </p>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </section>
            </section>

            <section className="panel two-col" aria-label="Personalized discovery">
              <section aria-labelledby="dashboard-recommended-title">
                <div className="panel-head">
                  <h2 id="dashboard-recommended-title">Recommended for you</h2>
                </div>
                {recommendationsLoading && <p className="muted">Updating recommendations...</p>}
                {!recommendationsLoading && recommendations.length === 0 && (
                  <p className="muted">No recommendations yet.</p>
                )}
                <div className="recommendation-shelf" role="list">
                  {recommendations.slice(0, 8).map((book) => (
                    <article
                      key={`dashboard-reco-${book.id}`}
                      className="shelf-card clickable-card"
                      role="listitem"
                      tabIndex={0}
                      aria-label={`Open details for ${book.title}`}
                      onClick={(event) => {
                        if (isInteractiveTarget(event.target)) {
                          return;
                        }
                        openBookDetails(book.id);
                      }}
                      onKeyDown={(event) => {
                        if (isInteractiveTarget(event.target)) {
                          return;
                        }
                        if (event.key === "Enter" || event.key === " ") {
                          event.preventDefault();
                          openBookDetails(book.id);
                        }
                      }}
                    >
                      <BookCover book={book} className="book-cover-thumb shelf-cover" />
                      <h3 className="shelf-title" title={book.title}>
                        {truncateText(book.title, 100)}
                      </h3>
                      <div className="book-card-subhead">
                        <p className="muted shelf-author" title={book.author}>
                          {truncateText(book.author, 70)}
                        </p>
                        <div className="title-row-icons">
                          <AiMetadataBadge book={book} />
                          <FavoriteStarButton
                            bookId={book.id}
                            isFavorite={book.isFavorite}
                            isPending={favoritePendingIds.includes(book.id)}
                            onToggle={toggleFavoriteBook}
                          />
                        </div>
                      </div>
                      <BookRating book={book} />
                      <p className="muted clamp-2 shelf-genre" title={book.genre ?? "General"}>
                        {truncateText(book.genre ?? "General", 90)}
                      </p>
                      <p className="muted clamp-2 shelf-description" title={book.description ?? "No description yet."}>
                        {truncateText(book.description ?? "No description yet.", 100)}
                      </p>
                      <p
                        className={`status-pill ${
                          book.requestPending ? "pending" : book.available ? "available" : "unavailable"
                        }`}
                      >
                        {book.requestPending
                          ? "Pending approval"
                          : book.available
                            ? "Checked in (returned)"
                            : "Checked out (borrowed)"}
                      </p>
                    </article>
                  ))}
                </div>
              </section>

              <section aria-labelledby="dashboard-favorites-title">
                <div className="panel-head">
                  <h2 id="dashboard-favorites-title">My favorites</h2>
                </div>
                {favoriteBooksLoading && <p className="muted">Loading favorites...</p>}
                {!favoriteBooksLoading && favoriteBooks.length === 0 && (
                  <p className="muted">No favorite books yet. Tap the star on any book card.</p>
                )}
                <div className="recommendation-shelf" role="list">
                  {favoriteBooks.map((book) => (
                    <article
                      key={`dashboard-fav-${book.id}`}
                      className="shelf-card clickable-card"
                      role="listitem"
                      tabIndex={0}
                      aria-label={`Open details for ${book.title}`}
                      onClick={(event) => {
                        if (isInteractiveTarget(event.target)) {
                          return;
                        }
                        openBookDetails(book.id);
                      }}
                      onKeyDown={(event) => {
                        if (isInteractiveTarget(event.target)) {
                          return;
                        }
                        if (event.key === "Enter" || event.key === " ") {
                          event.preventDefault();
                          openBookDetails(book.id);
                        }
                      }}
                    >
                      <BookCover book={book} className="book-cover-thumb shelf-cover" />
                      <h3 className="shelf-title" title={book.title}>
                        {truncateText(book.title, 100)}
                      </h3>
                      <div className="book-card-subhead">
                        <p className="muted shelf-author" title={book.author}>
                          {truncateText(book.author, 70)}
                        </p>
                        <div className="title-row-icons">
                          <AiMetadataBadge book={book} />
                          <FavoriteStarButton
                            bookId={book.id}
                            isFavorite={book.isFavorite}
                            isPending={favoritePendingIds.includes(book.id)}
                            onToggle={toggleFavoriteBook}
                          />
                        </div>
                      </div>
                      <BookRating book={book} />
                      <p className="muted clamp-2 shelf-genre" title={book.genre ?? "General"}>
                        {truncateText(book.genre ?? "General", 90)}
                      </p>
                      <p className="muted clamp-2 shelf-description" title={book.description ?? "No description yet."}>
                        {truncateText(book.description ?? "No description yet.", 100)}
                      </p>
                      <p
                        className={`status-pill ${
                          book.requestPending ? "pending" : book.available ? "available" : "unavailable"
                        }`}
                      >
                        {book.requestPending
                          ? "Pending approval"
                          : book.available
                            ? "Checked in (returned)"
                            : "Checked out (borrowed)"}
                      </p>
                    </article>
                  ))}
                </div>
              </section>
            </section>
          </>
        )}

        {viewMode === "settings" && user && (
          <>
            <section className="panel" aria-labelledby="contact-profile-title">
              <div className="panel-head">
                <h2 id="contact-profile-title">My contact profile</h2>
              </div>
              <p className="muted">Phone and contact email are used by admins for return reminders.</p>
              <div className="editor-grid contact-grid">
                <label>
                  Contact email
                  <input
                    type="email"
                    value={contactDraft.contactEmail}
                    onChange={(event) =>
                      setContactDraft((current) => ({ ...current, contactEmail: event.target.value }))
                    }
                    required
                  />
                </label>
                <label>
                  Phone number
                  <input
                    value={contactDraft.phoneNumber}
                    onChange={(event) =>
                      setContactDraft((current) => ({ ...current, phoneNumber: event.target.value }))
                    }
                    required
                  />
                </label>
                <label>
                  Personal ID (optional)
                  <input
                    value={contactDraft.personalId}
                    onChange={(event) =>
                      setContactDraft((current) => ({ ...current, personalId: event.target.value }))
                    }
                  />
                </label>
                <label>
                  Account email (Google SSO)
                  <input value={user.email} readOnly />
                </label>
              </div>
              <div className="row-actions">
                <button className="btn" type="button" onClick={() => void saveMyContactProfile()} disabled={savingContact}>
                  {savingContact ? "Saving..." : "Save contact profile"}
                </button>
              </div>
            </section>

            <section className="panel" aria-labelledby="appearance-title">
              <div className="panel-head">
                <h2 id="appearance-title">Appearance</h2>
              </div>
              <p className="muted">Choose your avatar and app background theme.</p>
              <div className="appearance-grid">
                <div>
                  <p className="profile-section-title">Avatar presets</p>
                  <div className="avatar-preset-grid">
                    {avatarPresets.map((preset) => (
                      <button
                        key={preset.id}
                        className={`avatar-preset-btn ${appearanceDraft.avatarPreset === preset.id ? "active" : ""}`}
                        type="button"
                        onClick={() => setAppearanceDraft((current) => ({ ...current, avatarPreset: preset.id }))}
                        aria-label={`Use ${preset.label} avatar`}
                      >
                        <span className="avatar-preset-circle" style={{ background: preset.innerBackground }}>
                          {preset.emoji}
                        </span>
                      </button>
                    ))}
                  </div>
                </div>
                <div>
                  <p className="profile-section-title">Background presets</p>
                  <div className="bg-preset-grid">
                    {backgroundPresets.map((preset) => (
                      <button
                        key={preset.id}
                        className={`bg-preset-btn ${appearanceDraft.backgroundPreset === preset.id ? "active" : ""}`}
                        type="button"
                        onClick={() => {
                          setAppearanceDraft((current) => ({ ...current, backgroundPreset: preset.id }));
                          document.body.style.background = preset.background;
                          document.body.style.color = preset.id === "bg-9" ? "#f1f5f9" : "";
                        }}
                        aria-label={`Use ${preset.label} background`}
                        title={preset.label}
                      >
                        <span className="bg-preset-preview" style={{ background: preset.background }} />
                      </button>
                    ))}
                  </div>
                </div>
              </div>
              <div className="row-actions">
                <button className="btn" type="button" onClick={() => void saveAppearancePreferences()} disabled={savingAppearance}>
                  {savingAppearance ? "Saving..." : "Save appearance"}
                </button>
              </div>
            </section>
          </>
        )}

        {viewMode === "dashboard" && user?.role === "ADMIN" && (
          <section className="panel import-box" aria-labelledby="import-title">
            <h2 id="import-title">Import books for testing</h2>
            <p className="muted">
              Import now automatically runs core auto-fill (rating/genre/covers/author) right after import.
            </p>
            <div className="import-grid">
              <label>
                Query
                <input value={importQuery} onChange={(event) => setImportQuery(event.target.value)} />
              </label>
              <label>
                Limit (1-300)
                <input
                  type="number"
                  min={1}
                  max={300}
                  value={importLimit}
                  onChange={(event) => setImportLimit(event.target.value)}
                />
              </label>
              <label>
                Source
                <select
                  value={importProvider}
                  onChange={(event) => setImportProvider(event.target.value as ImportProvider)}
                >
                  <option value="auto">Auto (Open Library then Google fallback)</option>
                  <option value="openlibrary">Open Library only</option>
                  <option value="google">Google Books only</option>
                </select>
              </label>
              <button
                className="btn"
                type="button"
                onClick={() => void importFromExternal()}
                disabled={importingExternal || enrichingCoreMetadata}
              >
                {importingExternal || enrichingCoreMetadata ? "Importing + auto-filling..." : "Import + auto-fill core"}
              </button>
            </div>
            <div className="import-actions">
              <label>
                Enrich limit (1-500)
                <input
                  type="number"
                  min={1}
                  max={500}
                  value={enrichLimit}
                  onChange={(event) => setEnrichLimit(event.target.value)}
                />
              </label>
              <button
                className="btn btn-outline"
                type="button"
                onClick={() => void enrichLibraryMetadata()}
                disabled={enrichingMetadata}
              >
                {enrichingMetadata ? "Enriching..." : "Enrich full metadata"}
              </button>
            </div>
          </section>
        )}

        {viewMode === "dashboard" && user?.role === "ADMIN" && (
          <section className="panel" aria-labelledby="admin-activity-logs-title">
            <div className="panel-head">
              <h2 id="admin-activity-logs-title">Activity logs</h2>
            </div>
            <ul className="stack-list">
              {adminLogs.length === 0 && <li className="muted">No activity logs yet.</li>}
              {adminLogs.map((entry) => (
                <li key={entry.id} className="row-item">
                  <div>
                    <p>{entry.text}</p>
                    <p className="muted">{new Date(entry.createdAt).toLocaleString()}</p>
                  </div>
                </li>
              ))}
            </ul>
          </section>
        )}

        {viewMode === "dashboard" && user?.role === "ADMIN" && (
          <section className="panel" aria-labelledby="borrowers-overview-title">
            <div className="panel-head">
              <h2 id="borrowers-overview-title">Borrowers and due alerts</h2>
              <button
                className="btn btn-outline"
                type="button"
                onClick={() => void loadAdminOverview()}
                disabled={adminOverviewLoading}
              >
                {adminOverviewLoading ? "Refreshing..." : "Refresh alerts"}
              </button>
            </div>
            {overdueLoans.length > 0 ? (
              <p className="overdue-banner">
                Alert: {overdueLoans.length} active loan(s) are overdue across {overdueUsersCount} borrower(s).
              </p>
            ) : (
              <p className="muted">No overdue loans right now.</p>
            )}

            <div className="borrowers-list">
              {borrowersOverview.length === 0 && <p className="muted">No active borrowers yet.</p>}
              {borrowersOverview.map((borrower) => (
                <article key={borrower.user.id} className="borrower-card">
                  <header>
                    <h3>{borrower.user.name}</h3>
                    <p className="muted">{borrower.user.email}</p>
                    <p className="muted">{`Level L${getLevelInfo(borrower.user.readingPoints).levelNumber}`}</p>
                    <p className={borrower.overdueCount > 0 ? "overdue-text" : "muted"}>
                      Active books: {borrower.activeLoans.length} | Overdue: {borrower.overdueCount}
                    </p>
                  </header>
                  <ul className="stack-list">
                    {borrower.activeLoans.map((loan) => {
                      const isOverdue = !!loan.dueAt && new Date(loan.dueAt) < new Date();
                      return (
                        <li key={loan.id} className="row-item">
                          <div>
                            <strong>{loan.book.title}</strong>
                            <p className={isOverdue ? "overdue-text" : "muted"}>
                              Due: {loan.dueAt ? new Date(loan.dueAt).toLocaleDateString() : "Not set"}
                            </p>
                          </div>
                          <button className="btn btn-outline" type="button" onClick={() => void checkinBook(loan.bookId)}>
                            Check in
                          </button>
                        </li>
                      );
                    })}
                  </ul>
                </article>
              ))}
            </div>
          </section>
        )}

        {viewMode === "dashboard" && user?.role === "ADMIN" && (
          <section className="panel" aria-labelledby="users-title">
            <div className="panel-head">
              <h2 id="users-title">User roles</h2>
              <button className="btn btn-outline" type="button" onClick={() => void loadUsers()} disabled={adminLoading}>
                Refresh users
              </button>
            </div>
            <p className="muted">Use this section to enforce role-based permissions for library operations.</p>
            <div className="table-wrap">
              <table>
                <caption className="sr-only">Users and role assignments</caption>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Account email</th>
                    <th>Contact email</th>
                    <th>Phone</th>
                    <th>ID</th>
                    <th>Level</th>
                    <th>Role</th>
                    <th>Update</th>
                  </tr>
                </thead>
                <tbody>
                  {users.map((member) => (
                    <tr key={member.id}>
                      <td>{member.name}</td>
                      <td>{member.email}</td>
                      <td>{member.contactEmail ?? member.email}</td>
                      <td>{member.phoneNumber ?? "Missing"}</td>
                      <td>{member.personalId ?? "-"}</td>
                      <td>{`L${getLevelInfo(member.readingPoints).levelNumber}`}</td>
                      <td>{member.role}</td>
                      <td>
                        <label className="sr-only" htmlFor={`role-${member.id}`}>
                          Set role for {member.name}
                        </label>
                        <select
                          id={`role-${member.id}`}
                          defaultValue={member.role}
                          onChange={(event) => void updateUserRole(member.id, event.target.value as Role)}
                        >
                          <option value="MEMBER">MEMBER</option>
                          <option value="ADMIN">ADMIN</option>
                        </select>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </section>
        )}
          </>
        )}
      </main>
      <BookPreviewDialog book={previewBook} onClose={() => setPreviewBook(null)} onCheckout={checkoutBook} />
    </>
  );
};

export default App;
